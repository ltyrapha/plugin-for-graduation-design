# -*- coding: utf-8 -*-
"""
/***************************************************************************
 demoDialog
                                 A QGIS plugin
 test
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-04-07
        git sha              : $Format:%H$
        copyright            : (C) 2023 by lty
        email                : tingyusahar@qq.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from PyQt5.QtCore import Qt, QObject, QRegExp, QMetaMethod
from PyQt5.QtGui import QColor, QStandardItemModel, QRegExpValidator, QStandardItem
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtWidgets import QMessageBox, QFileDialog, QHeaderView, QAbstractItemView
from qgis._gui import QgsRubberBand, QgsMapTool
from qgis.core import *

# This loads your .ui file so that PyQt c an populate your plugin with the elements from Qt Designer
from .map_tool import MapToolEmitPoint

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'demo_dialog_base.ui'))


class demoDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface=None, parent=None):
        """Constructor."""
        super(demoDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect

        self.setupUi(self)

        self.iface = iface
        self.roadfile = None
        self.vectorLayer = self.comboBoxInputRoad.currentLayer()
        self.canvas = self.iface.mapCanvas()  # 临时绘制点画布
        self.rb = QgsRubberBand(self.canvas, QgsWkbTypes.PointGeometry)  # 用于绘制临时点
        self.maptool = MapToolEmitPoint(self.canvas)  # 画布工具
        self.selecting = None  # 记录当前选择点是起点还是终点
        self.XLayer = None  # 起点图层
        self.YLayer = None  # 终点图层

        # 设置图层下拉框过滤器，仅选择线图层
        self.comboBoxInputRoad.setFilters(QgsMapLayerProxyModel.Filter.LineLayer)

        # 表格初始化设置
        self.modelX = QStandardItemModel()  # view对应的mode
        self.modelY = QStandardItemModel()
        self.tableViewPointX.setModel(self.modelX)
        self.tableViewPointY.setModel(self.modelY)
        self.modelX.setHorizontalHeaderLabels(['ID', '疏散人数', 'X', 'Y'])
        self.modelY.setHorizontalHeaderLabels(['ID', '疏散人数', 'X', 'Y'])
        # 水平方向，表格大小拓展到适当的尺寸
        self.tableViewPointX.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.tableViewPointY.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        # 整行选择和多选
        self.tableViewPointX.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.tableViewPointX.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.tableViewPointY.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.tableViewPointY.setSelectionMode(QAbstractItemView.ExtendedSelection)

        # 文本框初始化设置，仅能输入数字
        self.lineEditPointXNum.setValidator(QRegExpValidator(QRegExp("[0-9]{20}")))
        self.lineEditPointYNum.setValidator(QRegExpValidator(QRegExp("[0-9]{20}")))

        # 信号和槽连接
        # self.pushButtonClose.clicked.connect(self.close)
        self.pushButtonHelp.clicked.connect(self.help)
        self.pushButtonInputRoad.clicked.connect(self.inputRoad)
        # self.pushButtonDeleteRoad.clicked.connect(self.DeleteRoad)
        self.pushButtonInputPointX.clicked.connect(self.inputPoint)
        self.pushButtonCommitPointX.clicked.connect(self.commitPointX)
        self.pushButtonEndPointX.clicked.connect(self.endPoint)
        self.pushButtonDeletePointX.clicked.connect(self.deletePointX)
        self.pushButtonInputPointY.clicked.connect(self.inputPoint)
        self.pushButtonCommitPointY.clicked.connect(self.commitPointY)
        self.pushButtonEndPointY.clicked.connect(self.endPoint)
        self.pushButtonDeletePointY.clicked.connect(self.deletePointY)
        # self.pushButtonRun.clicked.connect(self.run)
        # self.pushButtonSaveRecord.clicked.connect(self.saveRecord)
        # self.pushButtonClearRecord.clicked.connect(self.clearRecord)

    def closeEvent(self, e):
        """关闭窗口触发"""
        self.selecting = None
        self.rb.reset(QgsWkbTypes.PointGeometry)
        self.canvas.setCursor(Qt.OpenHandCursor)
        self.canvas.unsetMapTool(self.maptool)
        self.XLayer = None
        self.YLayer = None
        self.destroy()

    def help(self):
        """帮助说明"""
        QMessageBox(QMessageBox.Information, "Information", "帮助：详情请见右侧算法描述").exec()

    def inputRoad(self):
        """选择一个路网数据文件加载进当前项目中"""
        filename, _ = QFileDialog.getOpenFileName(self, "输入", "", "road files(*.shp *.json)")
        if filename.strip() == "":
            QMessageBox(QMessageBox.Warning, "警告", "未选择可用路网数据").exec()
            return
        curlayer = QgsVectorLayer(filename, filename.split("/")[-1].split(".")[0], "ogr")
        if not curlayer.isValid() or (type(curlayer) != QgsVectorLayer) or (curlayer.geometryType() != 1):
            QMessageBox(QMessageBox.Warning, "警告", "图层加载失败：" + filename).exec()
        else:
            QMessageBox(QMessageBox.Information, "信息", "图层加载成功：" + filename).exec()
            self.vectorLayer = curlayer
            self.roadfile = filename
            QgsProject.instance().addMapLayer(curlayer)
            # self.comboBoxInputRoad.addItem(curlayer.name()) # 当删除图层时会出bug，将QComboBox换成QgsMapLayerComboBox后无需此句
            self.comboBoxInputRoad.setLayer(curlayer)

    def getCoordinates(self, e):
        """获取鼠标坐标"""
        self.hide()
        if self.rb.numberOfVertices() > 0:
            QMessageBox(QMessageBox.Information, "信息",
                        f"self.rb.numberOfVertices()={self.rb.numberOfVertices()}").exec()
            QMessageBox(QMessageBox.Warning, "警告", '请先确认上一个点').exec()
            self.show()
            return
        temp_point = self.maptool.toLayerCoordinates(self.vectorLayer, e.pos())
        self.rb.setFillColor(QColor(255, 0, 0))
        self.rb.addPoint(temp_point)
        # QMessageBox(QMessageBox.Information, "信息", f"{temp_point}").exec()
        self.show()
        if self.selecting == 'pushButtonInputPointX':
            self.tableViewPointX.clearSelection()
            self.lineEditPointXNum.setFocus()
        elif self.selecting == 'pushButtonInputPointY':
            self.tableViewPointY.clearSelection()
            self.lineEditPointYNum.setFocus()

    def inputPoint(self):
        """开始选择起终点"""
        # 防止选点混乱
        if self.selecting:
            QMessageBox(QMessageBox.Warning, "警告", "请先点击结束选点！").exec()
            return
        # 确定是起点还是终点
        self.selecting = self.sender().objectName()
        self.hide()
        self.canvas.setCursor(Qt.CrossCursor)
        self.canvas.setMapTool(self.maptool)
        self.maptool.canvasSingleClicked.connect(self.getCoordinates)

    def commitPointX(self):
        """确认选择起点"""
        # 获取临时绘制点信息
        tp = self.rb.getPoint(0)
        if not tp:
            QMessageBox(QMessageBox.Warning, "警告", "请先选择点！").exec()
            return
        num = self.lineEditPointXNum.text()
        if not num:  # 默认空为0
            num = '0'

        # 如果起点图层不存在则新建图层
        if not self.XLayer:
            self.XLayer = QgsVectorLayer("point?field=id:integer&field=num:interger&field=X:float&field=Y:float", "起点", "memory")
            self.XLayer.setCrs(QgsProject.instance().crs())
            QgsProject.instance().addMapLayer(self.XLayer)

        # 将点信息添加到表中，id取最后一行的id+1
        id = 1 if self.modelX.rowCount() == 0 else int(self.modelX.item(self.modelX.rowCount()-1, 0).text())+1
        item = [QStandardItem(str(id)), QStandardItem(num), QStandardItem(str(tp.x())), QStandardItem(str(tp.y()))]
        self.modelX.appendRow(item)

        # 添加要素
        dateProvider = self.XLayer.dataProvider()
        new_feature = QgsFeature()
        new_feature.setGeometry(QgsGeometry.fromPointXY(tp))
        new_feature.setAttributes([id, int(num), tp.x(), tp.y()])
        dateProvider.addFeature(new_feature)
        self.XLayer.updateExtents()

        # 清除临时绘制点
        self.rb.reset(QgsWkbTypes.PointGeometry)
        # 清空文本框
        self.lineEditPointXNum.clear()

    def commitPointY(self):
        """确认选择终点"""
        # 获取临时绘制点信息
        tp = self.rb.getPoint(0)
        if not tp:
            QMessageBox(QMessageBox.Warning, "警告", "请先选择点！").exec()
            return
        num = self.lineEditPointYNum.text()
        if not num:  # 默认空为0
            num = '0'

        # 如果终点图层不存在则新建图层
        if not self.YLayer:
            self.YLayer = QgsVectorLayer("point?field=id:integer&field=num:interger&field=X:float&field=Y:float", "终点", "memory")
            self.YLayer.setCrs(QgsProject.instance().crs())
            QgsProject.instance().addMapLayer(self.YLayer)

        # 将点信息添加到表中，id取最后一行的id+1
        id = 1 if self.modelY.rowCount() == 0 else int(self.modelY.item(self.modelY.rowCount()-1, 0).text())+1
        item = [QStandardItem(str(id)), QStandardItem(num), QStandardItem(str(tp.x())), QStandardItem(str(tp.y()))]
        self.modelY.appendRow(item)

        # 添加要素
        dateProvider = self.YLayer.dataProvider()
        new_feature = QgsFeature()
        new_feature.setGeometry(QgsGeometry.fromPointXY(tp))
        new_feature.setAttributes([id, int(num), tp.x(), tp.y()])
        dateProvider.addFeature(new_feature)
        self.YLayer.updateExtents()

        # 清除临时绘制点
        self.rb.reset(QgsWkbTypes.PointGeometry)
        # 清空文本框
        self.lineEditPointYNum.clear()

    def deletePointX(self):
        """删除起点"""
        # 如果用户选择了要删除的行，则倒序删除
        if len(self.tableViewPointX.selectedIndexes()) > 0:
            idxs = sorted(set(idx.row() for idx in self.tableViewPointX.selectedIndexes()), reverse=True)
            # 清除图层中的点
            self.XLayer.dataProvider().deleteFeatures(list(int(self.modelX.item(idx, 0).text()) for idx in idxs))
            # 清除表中的点
            for idx in idxs:
                self.modelX.removeRow(idx)
        # 如果用户未选择行，则清除rb中的临时绘制点
        elif self.rb.numberOfVertices() > 0:
            self.rb.reset(QgsWkbTypes.PointGeometry)
        # 如果用户未选择行且无临时点，则删除最后一行
        elif self.modelX.rowCount() > 0:
            self.XLayer.dataProvider().deleteFeatures([int(self.modelX.item(self.modelX.rowCount()-1, 0).text())])
            self.modelX.removeRow(self.modelX.rowCount() - 1)

    def deletePointY(self):
        """删除终点"""
        # 如果用户选择了要删除的行，则倒序删除
        if len(self.tableViewPointY.selectedIndexes()) > 0:
            idxs = sorted(set(idx.row() for idx in self.tableViewPointY.selectedIndexes()), reverse=True)
            # 清除图层中的点
            self.YLayer.dataProvider().deleteFeatures(list(int(self.modelY.item(idx, 0).text()) for idx in idxs))
            # 清除表中的点
            for idx in idxs:
                self.modelY.removeRow(idx)
        # 如果用户未选择行，则清除rb中的临时绘制点
        elif self.rb.numberOfVertices() > 0:
            self.rb.reset(QgsWkbTypes.PointGeometry)
        # 如果用户未选择行且无临时点，则删除最后一行
        elif self.modelY.rowCount() > 0:
            self.YLayer.dataProvider().deleteFeatures([int(self.modelY.item(self.modelY.rowCount() - 1, 0).text())])
            self.modelY.removeRow(self.modelY.rowCount() - 1)

    def endPoint(self):
        """结束选点，光标恢复正常，移除maptool"""
        self.selecting = None
        self.rb.reset(QgsWkbTypes.PointGeometry)
        self.canvas.setCursor(Qt.OpenHandCursor)
        self.maptool.canvasSingleClicked.disconnect(self.getCoordinates)
        self.canvas.unsetMapTool(self.maptool)